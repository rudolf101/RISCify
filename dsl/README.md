# Руководство по конфигурации дизассемблера для добавления поддержки расширений RISC-V

## Файлы

`.yml`-файлы в этом каталоге используются для описания форматов инструкций RISC-V.

В `schema.json` описана JSON-схема `.yml`-файлов, с помощью которой популярные редакторы и IDE могут их валидировать. 

## Формат файла

Каждый файл состоит из 4-разделов:
- `Arguments` — содержит список аргументов инструкций (опциональный раздел);
- `Fields` — содержит список полей инструкций (опциональный раздел);
- `Restricts` — содержит список ограничений на инструкции (опциональный раздел);
- `Sets` — содержит инструкции (обязательный раздел).

`Arguments` — ассоциативный массив, который строке ставит в соответствие структуру,
описывающую аргумент инструкции.
Эта структура состоит из полей:
- `name` — мнемоника аргумента, например `rd`, `uimm`;
- [`span`](#формат-span) — расположение аргумента в инструкции;
- [`display`](#формат-display) — формат отображения аргумента в дизассемблированном коде.

`Fields` — ассоциативный массив, который строке ставит в соответствие структуру,
описывающую поле инструкции.
Полем инструкции называются биты по значениям которых
можно распознать инструкцию.
Эта структура состоит из полей:
- `name` — мнемоника поля, например `opcode`, `funct3`;
- [`span`](#формат-span) — расположение поля в инструкции;
- `value` — значения, с которым сравниваются биты для распознания.

`Restricts` — подобен `Fields`, но содержит ограничения,
которые описывают состояния,
при которых инструкция не считается валидной.
Структура ограничения состоит из полей:
- [`span`](#формат-span) — расположение образца в инструкции;
- `value` — значение, которое не может быть у образца.

`Sets` — список из множеств инструкций.
Каждое множество описывается полями:
- `name` — название расширения, например `I` или `Zifencei`;
- `size` — размер инструкций в множестве в битах,
  например у расширения `I` 32-бита, а у расширения `C` — 16;
- `depth` — в какой разрядности (RV32 / RV64) инструкции в
  множестве имеют смысл, например `32` или `32|64|128`,
  значения идут по возрастанию через символ `|`
  (128-битная разрядность не полностью поддерживается дизассемблером);
- `instructions` — список с описаниями инструкций

Каждая инструкция описывается следующими полями:
- `mnemonic` — мнемоника инструкции, например `addi` или `c.j` (обязательно)
- `fields` — список строк, отсылающие к значениям из `Fields` (обязательно)
- `args` — список строк, отсылающие к значениям `Args`
- `restricts` — список строк, отсылающие к значениям `Restricts`
- `format` — формат отображения аргументов,
  по умолчанию аргументы перечисляются через запятую,
  но иногда нужен другой формат, например `_, _(_)`
- `jump` — если этого поля нет, считается,
  что инструкция не влияет на поток управления,
  если стоит значение `out`,
  считается, что невозможно отследить переход при дизассемблировании,
  если стоит число, то это число — номер аргумента (нумерация с 0),
  значение которого и является смещением перехода.

Примечания:
- В частях `Arguments`, `Fields` и `Restricts`
  перечисляются все значения, используемые в файле,
  затем на эти значения ссылаются описания инструкций
  по строковому ключу.
- Одно RISC-V расширение может быть разбито на несколько множеств инструкций,
  например, если в расширении есть инструкции, такие как `slli`,
  зависящие от разрядности.

## Формат `span`

```
span ::= range | range ',' span;
range ::= number | number ':' number;
number ::= { '0' .. '9' };
```

Поле `span` в некоторых структурах позволяет
вычленить из битового представления инструкции
отдельные биты для дальнейшего сравнения
или интерпретации.

В грамматике выше:
- `number` — это индекс бита.
  Отсчёт ведётся с нуля с младшего бита,
  иначе говоря со стороны, на которой находится
  `opcode` в 32-битных инструкциях.
- `range` — это отрезок из индексов,
  который может состоять как из одного индекса,
  так и из нескольких. Например отрезок `7:11`
  содержит индексы `7,8,9,10,11`.
- `span` — последовательность из индексов,
  собранная из отрезков. Эта последовательность
  может быть как угодно разорвана и перемешана
  (см. описание аргументов в файле [c.yml](./c.yml)),
  что позволяет гибко выделять биты из инструкции.

Примечание: подразумевается,
что все последовательности битов,
идут <u>от младшего к старшему</u>.

Для примера:
```
Начальная последовательность:
  11001010 00111101 00110010 10010100
  ↑                                 ↑
  0-й бит                    31-й бит

span:
  21:30,20,12:19,31
   ↓↓↓
  21,22,23,24,25,26,27,28,
  29,30,20,12,13,14,15,16,
  17,18,19,31

Вычлененная последовательность:
  01010010100110100110
  ↑                  ↑
  0-й бит     20-й бит

Как число она будет интерпретирована как
  01100101100101001010 (binary)
  ↑                  ↑
  20-й бит     0-й бит
   ↓↓↓
  416074 (decimal)
```

## Формат `display`

- `const(k)` — само число `k`, независимо от того,
  какие значения у битов.
- `regx` — регистр целых чисел (имена ABI).
- `regf` — регистр плавающих чисел (имена ABI).
- `regv` — регистр векторов.
- `regcx` — регистр целых чисел
  (имена ABI,
  3-битный аргумент для расширения C).
- `regcf` — регистр плавающих чисел
  (имена ABI,
  3-битный аргумент для расширения C).
- `regcv` — регистр векторов
  (пока не используется,
  3-битный аргумент для расширения C).
- `num` — знаковое число.
- `unum` — беззнаковое число.
- `numx(k)` — знаковое число,
  умноженное на $2^k$.
- `unumx(k)` — беззнаковое число,
  умноженное на $2^k$.
- `double` = `numx(1)`.
- `fence` — особый аргумент инструкции `fence`.
- `rm` — режим округления для инструкций из `FDQZfh`.
- `par(format)` — как `format`,
  только с круглыми скобками вокруг.

Примеры:

Напоминание: биты упорядочены от младшего к старшему.

| Биты    | `display`    | Результат |
|:--------|:-------------|:----------|
| `01000` | `regx`       | `sp`      |
| `110`   | `par(regсx)` | `(a1)`    |
| `111`   | `rm`         | `dyn`     |
| `1100`  | `fence`      | `rw`      |
| `0110`  | `num`        | `6`       |
| `0110`  | `unum`       | `6`       |
| `0111`  | `num`        | `14`      |
| `0111`  | `unum`       | `-2`      |
| `01010` | `const(42)`  | `42`      |

## Пример описания инструкций

### Пример для `bne`

В документации RISC-V написано,
что `bne` имеет структуру:

|`31:25`|`24:20`|`19:15`|`14:12`|`11:7`|`6:0`|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`imm[12\|10:5]`|`rs2`|`rs1`|`001`|`imm[4:1\|11]`|`1100011`|

Развернув её так, чтобы биты шли
от младшего к старшему получаем:

|`0:6`|`7:11`|`12:14`|`15:19`|`20:24`|`25:31`|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`1100011`|`imm[11\|1:4]`|`100`|`rs1`|`rs2`|`imm[5:10\|12]`|

Создаём описания полей
(могут быть переиспользованы
для нескольких инструкций):
```yaml
Fields:
  # ...
  rv32i_opcode_branch:
    name: "opcode"
    span: "0:6"
    value: "1100011"
  rv32i_funct3_bne:
    name: "funct3"
    span: "12:14"
    value: "100"
  # ...
```

Создаём описания аргументов
(могут быть переиспользованы
для нескольких инструкций):
```yaml
Args:
  # ...
  rv32i_rs1:
    name: "rs1"
    span: "15:19"
    display: "regx"
  rv32i_rs2:
    name: "rs2"
    span: "20:24"
    display: "regx"
  rv32i_b_imm:
    name: "imm" 
    span: "8:11,25:30,7,31"  # ! NB
    display: "double"  # переход осуществляется по 2 байта
  # ...
```

Обратите внимание, что диапазоны (`span`)
у аргументов должны быть выстроены так,
чтобы биты в них перечислялись от младшего к старшему.

Описание самой инструкции:

```yaml
Sets:
# ...
- name: "I"
  size: 32  # Инструкции шириной в 32 бита
  depth: "32|64"  # Инструкции работают в разрядностях RV32 и RV64
  instructions:
  # ...
  - mnemonic: "bne"
    fields: [ rv32i_opcode_branch, rv32i_funct3_bne ]
    args: [ rv32i_rs1, rv32i_rs2, rv32i_b_imm ]
    jump: 2  # ! NB: аргумент rv32i_b_imm содержит смещение перехода
  # ...
# ...
```

### Пример для `c.ldsp`

В документации RISC-V написано,
что `c.ldsp` имеет структуру:

|`15:13`|`12`|`11:7`|`6:2`|`1:0`|
|:-:|:-:|:-:|:-:|:-:|
|`011`|`uimm[5]`|`rd≠0`|`uimm[4:3\|8:6]`|`10`|

Развернув её так, чтобы биты шли
от младшего к старшему получаем:

|`0:1`|`2:6`|`7:11`|`12`|`13:15`|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`01`|`uimm[6:8\|3:4]`|`rd≠0`|`uimm[5]``110`|

Создаём описания полей:
```yaml
Fields:
  c_opcode_q2:
    name: "opcode"
    span: "0:1"
    value: "01"
  c_funct3_ldsp:
    name: "funct3"
    span: "13:15"
    value: "110"
```

Создаём описания аргументов:
```yaml
Args:
  c_full_rd:
    name: "rd"
    span: "7:11"
    display: "regx"
  c_ld_sp_uimm:
    name: "uimm"
    span: "5,6,12,2,3,4"
    display: "unumx(3)"
```

Создаём описания ограничений
(могут быть переиспользованы
для нескольких инструкций):
```yaml
Restricts:
  c_r_upper_no_zero:
    span: "7:11"
    value: "00000"  # Такого значения у инструкции быть не должно
```

Описание самой инструкции:

```yaml
Sets:
# ...
- name: "C"
  size: 16
  depth: "64|128"
  instructions:
  # ...
  - mnemonic: "c.ldsp"
    fields: [ c_opcode_q2, c_funct3_ldsp ]
    restricts: [ c_r_upper_no_zero ]
    args: [ c_full_rd, c_ld_sp_uimm ]
    format: "_, _(sp)"  # Вместо перечисления аргументов через запятую
  # ...
# ...
```
